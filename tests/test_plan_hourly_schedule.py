"""tests/test_plan_hourly_schedule.py -- generate_hourly_schedule unit tests.

Updated for batch-mode hourly schedule generation where all remaining hours
are generated in a single GPT call via run_gpt_prompt_generate_hourly_schedule_batch.
"""
from unittest.mock import MagicMock

import pytest

from persona.cognitive_modules import plan as plan_mod
from persona.cognitive_modules.plan import generate_hourly_schedule

# Monkeypatch target: the module-level name inside plan.py
_BATCH_ATTR = "run_gpt_prompt_generate_hourly_schedule_batch"


def _make_persona():
    """Create a minimal persona mock with scratch attribute."""
    persona = MagicMock()
    persona.scratch = MagicMock()
    return persona


# ── 1. wake_up_hour=0 → first entry is NOT "sleeping" ───────────────────

def test_wake_up_0_no_sleeping(monkeypatch):
    activities = ["reading a book"] * 24
    monkeypatch.setattr(plan_mod, _BATCH_ATTR,
                        lambda *a, **kw: (activities, None))
    result = generate_hourly_schedule(_make_persona(), 0)
    assert result[0][0] != "sleeping"


# ── 2. wake_up_hour=8 → first entry is ["sleeping", 480] ────────────────

def test_wake_up_8_sleeping_480min(monkeypatch):
    # 16 remaining hours after wake_up_hour=8
    activities = ["cooking", "eating", "walking", "reading", "painting",
                  "sleeping", "chatting", "working", "cooking", "eating",
                  "walking", "reading", "painting", "sleeping", "chatting",
                  "working"]

    monkeypatch.setattr(plan_mod, _BATCH_ATTR,
                        lambda *a, **kw: (activities, None))
    result = generate_hourly_schedule(_make_persona(), 8)
    assert result[0] == ["sleeping", 480]


# ── 3. total minutes always sums to 1440 ────────────────────────────────

def test_total_minutes_1440(monkeypatch):
    # wake_up_hour=6 → 18 remaining hours
    activities = ["working on painting"] * 18
    monkeypatch.setattr(plan_mod, _BATCH_ATTR,
                        lambda *a, **kw: (activities, None))
    result = generate_hourly_schedule(_make_persona(), 6)
    total = sum(duration for _, duration in result)
    assert total == 1440


# ── 4. consecutive same activities are merged ────────────────────────────

def test_compression_consecutive(monkeypatch):
    # wake_up_hour=2 → 22 remaining hours
    sequence = (
        ["cooking"] + ["eating"] + ["walking"] * 5 + ["reading"] + ["painting"]
        + ["cooking"] + ["eating"] + ["walking"] * 5 + ["reading"] + ["painting"]
        + ["cooking"] + ["eating"] + ["walking"] * 2
    )  # 22 items, 5 unique

    monkeypatch.setattr(plan_mod, _BATCH_ATTR,
                        lambda *a, **kw: (sequence, None))
    result = generate_hourly_schedule(_make_persona(), 2)
    # sleeping should be merged: 2 hours → 120 min
    assert result[0] == ["sleeping", 120]
    # The consecutive "walking" block (5 hours) should be merged into one entry
    assert result[3] == ["walking", 300]


# ── 5. alternating activities are NOT merged ─────────────────────────────

def test_compression_alternating(monkeypatch):
    activities = []
    for i in range(24):
        activities.append("activity_a" if i % 2 == 0 else "activity_b")

    monkeypatch.setattr(plan_mod, _BATCH_ATTR,
                        lambda *a, **kw: (activities, None))
    result = generate_hourly_schedule(_make_persona(), 0)
    # Each hour should be its own entry since activities alternate
    assert len(result) == 24
    for _, duration in result:
        assert duration == 60


# ── 6. each duration is a multiple of 60 ────────────────────────────────

def test_minute_conversion(monkeypatch):
    # wake_up_hour=3 → 21 remaining hours
    activities = ["cooking", "eating", "walking", "reading", "painting",
                  "sleeping", "chatting"] * 3  # 21 items
    monkeypatch.setattr(plan_mod, _BATCH_ATTR,
                        lambda *a, **kw: (activities, None))
    result = generate_hourly_schedule(_make_persona(), 3)
    for _, duration in result:
        assert duration % 60 == 0, f"Duration {duration} is not a multiple of 60"


# ── 7. batch mode: sleeping entries are added programmatically ────────────

def test_sleeping_not_from_gpt(monkeypatch):
    """With batch mode, sleeping hours before wake_up are added directly,
    not generated by GPT. The batch call only covers remaining hours."""
    call_args_list = []

    def _tracking(persona, remaining_hours, hour_str, **kw):
        call_args_list.append(remaining_hours)
        return (["painting"] * len(remaining_hours), None)

    monkeypatch.setattr(plan_mod, _BATCH_ATTR, _tracking)
    generate_hourly_schedule(_make_persona(), 10)

    # The batch call should only receive 14 remaining hours (24-10)
    assert len(call_args_list[0]) == 14


# ── 8. diversity retry triggered when <5 unique activities ───────────────

def test_diversity_retry_triggered(monkeypatch):
    call_count = {"n": 0}

    def _few_unique(persona, remaining_hours, hour_str, **kw):
        call_count["n"] += 1
        return (["only_one_activity"] * len(remaining_hours), None)

    monkeypatch.setattr(plan_mod, _BATCH_ATTR, _few_unique)
    # wake_up_hour=0 → all 24 hours via batch.
    # 1 unique activity (+ "sleeping"=0 sleeping) < 5 → all 3 iterations run.
    generate_hourly_schedule(_make_persona(), 0)
    # 3 batch calls (one per diversity_repeat_count iteration)
    assert call_count["n"] == 3


# ── 9. diversity retry NOT triggered when >=5 unique activities ──────────

def test_diversity_retry_not_triggered(monkeypatch):
    call_count = {"n": 0}

    def _diverse(persona, remaining_hours, hour_str, **kw):
        call_count["n"] += 1
        activities = ["cooking", "eating", "walking", "reading", "painting",
                      "sleeping", "chatting"]
        result = []
        for i in range(len(remaining_hours)):
            result.append(activities[i % len(activities)])
        return (result, None)

    monkeypatch.setattr(plan_mod, _BATCH_ATTR, _diverse)
    # >=5 unique → first call (i==0) always runs, second skipped (>=5), third skipped
    generate_hourly_schedule(_make_persona(), 0)
    # Only 1 batch call (i==0 always runs, subsequent skipped because >=5 unique)
    assert call_count["n"] == 1


# ── 10. batch call receives correct remaining hours ──────────────────────

def test_batch_receives_correct_hours(monkeypatch):
    call_args_list = []

    def _tracking(persona, remaining_hours, hour_str, **kw):
        call_args_list.append((remaining_hours, hour_str))
        return (["painting"] * len(remaining_hours), None)

    monkeypatch.setattr(plan_mod, _BATCH_ATTR, _tracking)
    wake_up_hour = 10
    generate_hourly_schedule(_make_persona(), wake_up_hour)

    remaining, full_hours = call_args_list[0]
    assert len(full_hours) == 24
    assert remaining[0] == "10:00 AM"
    assert len(remaining) == 14
